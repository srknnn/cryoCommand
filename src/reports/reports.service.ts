import {
  Injectable,
  NotFoundException,
  StreamableFile,
} from '@nestjs/common';
import { v4 as uuidv4 } from 'uuid';
import * as PDFDocument from 'pdfkit';
import { PrismaService } from '../prisma/prisma.service';
import { ReportCreateDto, ReportResponseDto } from './dto';

@Injectable()
export class ReportsService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * Get all reports
   * GET /api/reports
   */
  async findAll(): Promise<ReportResponseDto[]> {
    const reports = await this.prisma.report.findMany({
      orderBy: { created_at: 'desc' },
      take: 100,
    });

    return reports.map((r) => this.toReportResponse(r));
  }

  /**
   * Create a new report
   * POST /api/reports
   */
  async create(dto: ReportCreateDto, userName: string): Promise<ReportResponseDto> {
    const reportId = uuidv4();
    const now = new Date();

    const report = await this.prisma.report.create({
      data: {
        visibleId: reportId,
        name: dto.name,
        vehicle_ids: dto.vehicle_ids ?? [],
        start_date: dto.start_date,
        end_date: dto.end_date,
        report_type: dto.report_type ?? 'temperature',
        status: 'completed',
        created_at: now,
        created_by: userName,
      },
    });

    return this.toReportResponse(report);
  }

  /**
   * Download report as PDF
   * GET /api/reports/:report_id/download
   */
  async downloadReport(reportId: string): Promise<StreamableFile> {
    const report = await this.prisma.report.findUnique({
      where: { visibleId: reportId },
    });

    if (!report) {
      throw new NotFoundException('Report not found');
    }

    // Get readings data based on vehicle_ids filter
    const where: any = {};
    if (report.vehicle_ids && report.vehicle_ids.length > 0) {
      where.vehicle_id = { in: report.vehicle_ids };
    }

    const readings = await this.prisma.sensorReading.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      take: 500,
    });

    // Create PDF document
    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];

    doc.on('data', (chunk: Buffer) => chunks.push(chunk));

    // Colors
    const primaryColor = '#0d9488';
    const headerBg = '#1e293b';

    // Title
    doc
      .fillColor(primaryColor)
      .fontSize(20)
      .text(`Cold Chain Report: ${report.name}`, { align: 'center' });
    doc.moveDown(1);

    // Report Info
    doc.fillColor('#333').fontSize(12);
    doc.text(`Period: ${report.start_date} to ${report.end_date}`);
    doc.text(`Generated by: ${report.created_by}`);
    doc.text(`Report Type: ${report.report_type}`);
    doc.text(`Created: ${report.created_at.toISOString().slice(0, 19).replace('T', ' ')}`);
    doc.moveDown(2);

    // Table Header
    if (readings.length > 0) {
      doc.fillColor(primaryColor).fontSize(14).text('Sensor Readings');
      doc.moveDown(1);

      // Table
      const tableTop = doc.y;
      const col1 = 50;
      const col2 = 180;
      const col3 = 280;
      const col4 = 380;
      const rowHeight = 20;

      // Header row
      doc.fillColor('#fff').fontSize(10);
      doc
        .rect(col1 - 5, tableTop - 5, 470, rowHeight)
        .fill(primaryColor);
      doc
        .fillColor('#fff')
        .text('Vehicle ID', col1, tableTop, { width: 120 })
        .text('Temperature', col2, tableTop, { width: 90 })
        .text('Humidity', col3, tableTop, { width: 90 })
        .text('Timestamp', col4, tableTop, { width: 150 });

      // Data rows
      let y = tableTop + rowHeight;
      const displayReadings = readings.slice(0, 50);

      for (let i = 0; i < displayReadings.length; i++) {
        const r = displayReadings[i];
        const bgColor = i % 2 === 0 ? '#f8fafc' : '#fff';

        doc.rect(col1 - 5, y - 3, 470, rowHeight).fill(bgColor);
        doc
          .fillColor('#333')
          .fontSize(9)
          .text(r.vehicle_id.slice(0, 15), col1, y, { width: 120 })
          .text(`${r.temperature.toFixed(1)}Â°C`, col2, y, { width: 90 })
          .text(`${r.humidity.toFixed(0)}%`, col3, y, { width: 90 })
          .text(r.timestamp.toISOString().slice(0, 19).replace('T', ' '), col4, y, {
            width: 150,
          });

        y += rowHeight;

        // Check for page break
        if (y > 700) {
          doc.addPage();
          y = 50;
        }
      }

      if (readings.length > 50) {
        doc.moveDown(1);
        doc
          .fillColor('#666')
          .fontSize(10)
          .text(`... and ${readings.length - 50} more readings`);
      }
    } else {
      doc
        .fillColor('#666')
        .fontSize(12)
        .text('No sensor readings found for selected period.');
    }

    // Footer
    doc.moveDown(3);
    doc
      .fillColor('#999')
      .fontSize(9)
      .text(
        'Generated by CryoCommand Cold Chain Monitoring System',
        { align: 'center' },
      );

    doc.end();

    // Wait for PDF to be generated
    return new Promise((resolve) => {
      doc.on('end', () => {
        const pdfBuffer = Buffer.concat(chunks);
        resolve(new StreamableFile(pdfBuffer));
      });
    });
  }

  /**
   * Get filename for PDF report
   */
  getPdfFilename(reportName: string): string {
    // Sanitize filename
    const safeName = reportName.replace(/[^a-zA-Z0-9-_]/g, '_');
    return `${safeName}.pdf`;
  }

  /**
   * Get report by ID (for filename generation)
   */
  async getReport(reportId: string): Promise<ReportResponseDto> {
    const report = await this.prisma.report.findUnique({
      where: { visibleId: reportId },
    });

    if (!report) {
      throw new NotFoundException('Report not found');
    }

    return this.toReportResponse(report);
  }

  /**
   * Convert Prisma Report to ReportResponseDto
   */
  private toReportResponse(report: any): ReportResponseDto {
    return {
      id: report.visibleId,
      name: report.name,
      vehicle_ids: report.vehicle_ids,
      start_date: report.start_date,
      end_date: report.end_date,
      report_type: report.report_type,
      status: report.status,
      created_at: report.created_at.toISOString(),
      created_by: report.created_by,
    };
  }
}
